use std::collections::HashMap;
use std::sync::LazyLock;

use swc_core::common::{DUMMY_SP, Spanned, comments::Comments, errors::HANDLER};
use swc_core::ecma::ast::Id;
use swc_core::ecma::ast::*;
use swc_core::ecma::visit::{VisitMut, VisitMutWith, visit_mut_pass};

use crate::token_map::TokenMap;

pub mod token_map;
pub mod generated {
  // Generated by tokens build step
  // token_data.rs defines TOKEN_NAMES, LIGHT_VALUES, LEGACY_LIGHT_VALUES, SHAPE_VALUES, SPACING_VALUES, TYPOGRAPHY_VALUES
  include!("generated/token_data.rs");
}

static TOKEN_NAMES_MAP: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
  let mut m = HashMap::with_capacity(generated::TOKEN_NAMES.len());
  for (k, v) in generated::TOKEN_NAMES.iter() {
    m.insert(*k, *v);
  }
  m
});

static LIGHT_VALUES_MAP: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
  let mut m = HashMap::with_capacity(generated::LIGHT_VALUES.len());
  for (k, v) in generated::LIGHT_VALUES.iter() {
    m.insert(*k, *v);
  }
  m
});

static LEGACY_LIGHT_VALUES_MAP: LazyLock<HashMap<&'static str, &'static str>> =
  LazyLock::new(|| {
    let mut m = HashMap::with_capacity(generated::LEGACY_LIGHT_VALUES.len());
    for (k, v) in generated::LEGACY_LIGHT_VALUES.iter() {
      m.insert(*k, *v);
    }
    m
  });

static SHAPE_VALUES_MAP: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
  let mut m = HashMap::with_capacity(generated::SHAPE_VALUES.len());
  for (k, v) in generated::SHAPE_VALUES.iter() {
    m.insert(*k, *v);
  }
  m
});

static SPACING_VALUES_MAP: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
  let mut m = HashMap::with_capacity(generated::SPACING_VALUES.len());
  for (k, v) in generated::SPACING_VALUES.iter() {
    m.insert(*k, *v);
  }
  m
});

static TYPOGRAPHY_VALUES_MAP: LazyLock<HashMap<&'static str, &'static str>> = LazyLock::new(|| {
  let mut m = HashMap::with_capacity(generated::TYPOGRAPHY_VALUES.len());
  for (k, v) in generated::TYPOGRAPHY_VALUES.iter() {
    m.insert(*k, *v);
  }
  m
});

pub fn design_system_tokens_visitor<C>(
  comments: C,
  should_use_auto_fallback: bool,
  should_force_auto_fallback: bool,
  force_auto_fallback_exemptions: Vec<String>,
  default_theme: String,
  is_node_modules: bool,
  token_map: Option<&TokenMap>,
) -> impl Pass
where
  C: Comments,
{
  visit_mut_pass(TokensPass {
    _comments: comments,
    should_use_auto_fallback,
    should_force_auto_fallback,
    force_auto_fallback_exemptions,
    default_theme,
    is_node_modules,
    token_local_ids: vec![],
    token_map,
  })
}

struct TokensPass<'a, C>
where
  C: Comments,
{
  _comments: C,
  should_use_auto_fallback: bool,
  should_force_auto_fallback: bool,
  force_auto_fallback_exemptions: Vec<String>,
  default_theme: String,
  is_node_modules: bool,
  token_local_ids: Vec<Id>,
  token_map: Option<&'a TokenMap>,
}

impl<'a, C> TokensPass<'a, C>
where
  C: Comments,
{
  /// Helper function to get a value from either the provided token_map or fallback to baked-in maps
  fn get_from_map<F>(
    &self,
    key: &str,
    token_map_accessor: F,
    fallback_map: &HashMap<&'static str, &'static str>,
  ) -> Option<String>
  where
    F: Fn(&TokenMap) -> &HashMap<String, String>,
  {
    if let Some(token_map) = self.token_map {
      token_map_accessor(token_map).get(key).cloned()
    } else {
      fallback_map.get(key).map(|s| s.to_string())
    }
  }

  fn is_exempted(&self, token_name: &str) -> bool {
    if token_name.starts_with("radius") {
      return true;
    }
    self
      .force_auto_fallback_exemptions
      .iter()
      .any(|p| token_name.starts_with(p))
  }

  fn get_default_fallback(&self, token_name: &str) -> Option<String> {
    // Try shape values first
    if let Some(v) = self.get_from_map(token_name, |tm| &tm.shape_values, &SHAPE_VALUES_MAP) {
      return Some(v);
    }
    // Try spacing values
    if let Some(v) = self.get_from_map(token_name, |tm| &tm.spacing_values, &SPACING_VALUES_MAP) {
      return Some(v);
    }
    // Try typography values
    if let Some(v) = self.get_from_map(
      token_name,
      |tm| &tm.typography_values,
      &TYPOGRAPHY_VALUES_MAP,
    ) {
      return Some(v);
    }
    // Try color values (theme-dependent)
    if self.default_theme == "legacy-light" {
      self.get_from_map(
        token_name,
        |tm| &tm.legacy_light_values,
        &LEGACY_LIGHT_VALUES_MAP,
      )
    } else {
      self.get_from_map(token_name, |tm| &tm.light_values, &LIGHT_VALUES_MAP)
    }
  }
}

impl<'a, C> VisitMut for TokensPass<'a, C>
where
  C: Comments,
{
  fn visit_mut_module(&mut self, m: &mut Module) {
    // collect local names for `token` imported from '@atlaskit/tokens'
    self.token_local_ids.clear();
    let mut token_import_local_ids: Vec<Id> = vec![];

    // Collect import specifiers from '@atlaskit/tokens'
    for item in &m.body {
      if let ModuleItem::ModuleDecl(ModuleDecl::Import(ImportDecl {
        src, specifiers, ..
      })) = item
        && src.value.as_ref() == "@atlaskit/tokens"
      {
        for s in specifiers {
          if let ImportSpecifier::Named(is) = s {
            if let Some(imported) = &is.imported {
              match imported {
                ModuleExportName::Ident(ident) => {
                  if ident.sym.as_ref() == "token" {
                    token_import_local_ids.push(is.local.to_id());
                  }
                }
                ModuleExportName::Str(str_) => {
                  if str_.value.as_ref() == "token" {
                    token_import_local_ids.push(is.local.to_id());
                  }
                }
              }
            } else {
              // import { token } without aliasing
              if is.local.sym.as_ref() == "token" {
                token_import_local_ids.push(is.local.to_id());
              }
            }
          }
        }
      }
    }
    self.token_local_ids = token_import_local_ids.clone();

    // Walk and transform calls
    use swc_core::ecma::visit::VisitMutWith;
    for item in &mut m.body {
      item.visit_mut_with(self);
    }

    // Cleanup unused token imports: conservative â€“ if no usages remain, drop
    if !token_import_local_ids.is_empty() {
      // Determine if any of the token local names are still referenced
      let used_ids: Vec<Id> = token_import_local_ids
        .iter()
        .filter(|&id| identifier_id_used_in_module(m, id.clone()))
        .cloned()
        .collect();
      m.body.iter_mut().for_each(|item| {
        if let ModuleItem::ModuleDecl(ModuleDecl::Import(import_decl)) = item
          && import_decl.src.value.as_ref() == "@atlaskit/tokens"
        {
          import_decl.specifiers.retain(|s| {
            if let ImportSpecifier::Named(is) = s {
              // If this specifier is a token import and it's not used, remove it
              let is_token_import = if let Some(imported) = &is.imported {
                match imported {
                  ModuleExportName::Ident(id) => id.sym.as_ref() == "token",
                  ModuleExportName::Str(st) => st.value.as_ref() == "token",
                }
              } else {
                is.local.sym.as_ref() == "token"
              };
              if is_token_import {
                // keep only if still used by name
                used_ids.contains(&is.local.to_id())
              } else {
                true
              }
            } else {
              true
            }
          });
        }
      });
      // Remove entire import if empty
      m.body.retain(|item| match item {
        ModuleItem::ModuleDecl(ModuleDecl::Import(import_decl))
          if import_decl.src.value.as_ref() == "@atlaskit/tokens" =>
        {
          !import_decl.specifiers.is_empty()
        }
        _ => true,
      });
    }
  }

  fn visit_mut_expr(&mut self, e: &mut Expr) {
    if self.is_node_modules {
      return;
    }
    e.visit_mut_children_with(self);
    let call = match e {
      Expr::Call(c) => c,
      _ => return,
    };
    // Only handle token(...) calls with identifier callee named 'token'
    let callee_ident = match &call.callee {
      Callee::Expr(c) => match &**c {
        Expr::Ident(i) => i,
        _ => return,
      },
      _ => return,
    };
    if !self
      .token_local_ids
      .iter()
      .any(|id| *id == callee_ident.to_id())
    {
      return;
    }

    if call.args.is_empty() {
      HANDLER.with(|h| h.span_err(call.span, "token() requires at least one argument"));
      return;
    }
    let first = &call.args[0].expr;
    let token_name = match &**first {
      Expr::Lit(Lit::Str(s)) => s.value.to_string(),
      _ => {
        HANDLER.with(|h| {
          h.span_err(
            first.span(),
            "token() must have a string literal as the first argument",
          )
        });
        return;
      }
    };
    if call.args.len() > 2 {
      HANDLER.with(|h| {
        h.span_err(
          call.span,
          &format!("token() does not accept {} arguments", call.args.len()),
        )
      });
      return;
    }

    let css_token_value =
      match self.get_from_map(token_name.as_str(), |tm| &tm.token_names, &TOKEN_NAMES_MAP) {
        Some(v) => v,
        None => {
          HANDLER.with(|h| {
            h.span_err(
              first.span(),
              &format!("token '{}' does not exist", token_name),
            )
          });
          return;
        }
      };

    let new_expr: Expr = if call.args.len() < 2 {
      if self.should_use_auto_fallback {
        if let Some(fallback) = self.get_default_fallback(&token_name) {
          Expr::Lit(Lit::Str(Str {
            value: format!("var({}, {})", css_token_value, fallback).into(),
            raw: None,
            span: DUMMY_SP,
          }))
        } else {
          Expr::Lit(Lit::Str(Str {
            value: format!("var({})", css_token_value).into(),
            raw: None,
            span: DUMMY_SP,
          }))
        }
      } else {
        Expr::Lit(Lit::Str(Str {
          value: format!("var({})", css_token_value).into(),
          raw: None,
          span: DUMMY_SP,
        }))
      }
    } else {
      let mut fallback_expr = call.args[1].expr.clone();
      let force = self.should_force_auto_fallback && !self.is_exempted(&token_name);
      if force && let Some(v) = self.get_default_fallback(&token_name) {
        fallback_expr = Box::new(Expr::Lit(Lit::Str(Str {
          value: v.into(),
          raw: None,
          span: DUMMY_SP,
        })));
      }
      match *fallback_expr {
        Expr::Lit(Lit::Str(ref s)) => {
          let v = s.value.to_string();
          if v.is_empty() {
            Expr::Lit(Lit::Str(Str {
              value: format!("var({})", css_token_value).into(),
              raw: None,
              span: DUMMY_SP,
            }))
          } else {
            Expr::Lit(Lit::Str(Str {
              value: format!("var({}, {})", css_token_value, v).into(),
              raw: None,
              span: DUMMY_SP,
            }))
          }
        }
        other => {
          let raw_head = format!("var({}, ", escape_for_tpl_raw(&css_token_value));
          Expr::Tpl(Tpl {
            span: DUMMY_SP,
            exprs: vec![Box::new(other)],
            quasis: vec![
              TplElement {
                span: DUMMY_SP,
                cooked: Some(raw_head.clone().into()),
                raw: raw_head.into(),
                tail: false,
              },
              TplElement {
                span: DUMMY_SP,
                cooked: Some(")".into()),
                raw: ")".into(),
                tail: true,
              },
            ],
          })
        }
      }
    };

    *e = new_expr;
  }
}

fn identifier_id_used_in_module(m: &Module, target: Id) -> bool {
  struct Finder {
    target: Id,
    found: bool,
  }
  impl swc_core::ecma::visit::Visit for Finder {
    fn visit_ident(&mut self, i: &Ident) {
      if i.to_id() == self.target {
        self.found = true;
      }
    }

    fn visit_import_decl(&mut self, _n: &ImportDecl) {
      // Don't visit imports
    }
  }
  use swc_core::ecma::visit::VisitWith;
  let mut f = Finder {
    target,
    found: false,
  };
  m.visit_with(&mut f);
  f.found
}

fn escape_for_tpl_raw(input: &str) -> String {
  // Mirror Babel: replace \\ , ` , \${ in raw
  let mut s = input.replace("\\", "\\\\");
  s = s.replace("`", "\\`");
  s = s.replace("${", "\\${");
  s
}
