// @flow strict-local

import fs from 'fs';
import childProcess from 'child_process';
import assert from 'assert';
import path from 'path';
import {NodeVCSAwareFS} from '@atlaspack/fs';
import {bundle, assertBundles, workerFarm} from '@atlaspack/test-utils';

it('can parse a git commit message hash', () => {
  const example = '[master (root-commit) e997505] Initial commit';
  assert.equal(parseGitCommitMessageHash(example), 'e997505');
});

const execStdio = 'pipe';

function parseGitCommitMessageHash(message: string) {
  const match = message.match(/\[.*([0-9a-f]{7})\]/);
  if (!match) {
    throw new Error('No hash found in git commit message');
  }
  return match[1];
}

function getTemporaryDirectory() {
  // watchman can't watch the macOS temporary directory, so we use a local
  // directory instead.
  // use $GIT_ROOT/tmp
  return path.join(
    __dirname,
    '..',
    '..',
    '..',
    '..',
    'tmp',
    `vcs-cache-test-${process.pid}-${Date.now()}`,
  );
}

function setupGitRepository() {
  // Create a temporary directory with a git repository and 3 javascript files.
  // the files should be modified over time, and we will use their history to
  // test that the cache can read changes from git revisions.
  // Since we need to interact with git, we will use the real file-system
  // to create the files and directories.

  const root = getTemporaryDirectory();
  fs.mkdirSync(root, {recursive: true});
  childProcess.execSync('git init', {cwd: root, stdio: execStdio});
  childProcess.execSync('git config user.email "test@example.com"', {
    cwd: root,
    stdio: execStdio,
  });
  childProcess.execSync('git config user.name "Test User"', {
    cwd: root,
    stdio: execStdio,
  });

  // gitignore the .parcel-cache directory
  fs.writeFileSync(
    path.join(root, '.gitignore'),
    '.parcel-cache\nnode_modules\n',
  );

  const file1 = path.join(root, 'file1.js');
  const file2 = path.join(root, 'file2.js');
  const file3 = path.join(root, 'file3.js');

  // write a package.json
  fs.writeFileSync(
    path.join(root, 'package.json'),
    '{"name": "vcs-cache-test"}',
  );

  // write a yarn.lock file
  const yarnLockFileContentsAtStart = `
# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 8
  cacheKey: 10c0

"lodash@npm:^3":
  version: 3.10.1
  resolution: "lodash@npm:3.10.1"
  checksum: 10c0/f5f6d3d87503c3f1db27d49b30a00bb38dc1bd9de716c5febe8970259cc7b447149a0e320452ccaf5996a7a4abd63d94df341bb91bd8d336584ad518d8eab144
  languageName: node
  linkType: hard

"sample_repository@workspace:.":
  version: 0.0.0-use.local
  resolution: "sample_repository@workspace:."
  dependencies:
    lodash: "npm:^3"
  languageName: unknown
  linkType: soft

`.trim();
  fs.writeFileSync(path.join(root, 'yarn.lock'), yarnLockFileContentsAtStart);

  // write the yarn-state.yml file
  const yarnStateFileContents = `
# Warning: This file is automatically generated. Removing it is fine, but will
# cause your node_modules installation to become invalidated.

__metadata:
  version: 1
  nmMode: classic

"lodash@npm:4.17.21":
  locations:
    - "node_modules/lodash"

"sample_repository@workspace:.":
  locations:
    - ""

  `.trim();
  fs.mkdirSync(path.join(root, 'node_modules'), {recursive: true});
  fs.writeFileSync(
    path.join(root, 'node_modules', '.yarn-state.yml'),
    yarnStateFileContents,
  );

  // write some files into node_modules/lodash/
  fs.mkdirSync(path.join(root, 'node_modules', 'lodash', 'src'), {
    recursive: true,
  });
  fs.writeFileSync(
    path.join(root, 'node_modules', 'lodash', 'file1.js'),
    'module.exports = "one"',
  );
  fs.writeFileSync(
    path.join(root, 'node_modules', 'lodash', 'src', 'file2.js'),
    'module.exports = "two"',
  );

  // file1 is the entry, file2 and file3 are dependencies.
  // file1 console.logs the value of file2 and file3.
  // file2 and file3 console.log "Hello, world!"
  fs.writeFileSync(
    file1,
    'console.log(require("./file2"), require("./file3"));',
  );
  fs.writeFileSync(file2, 'module.exports = "one"');
  fs.writeFileSync(file3, 'module.exports = "two"');

  childProcess.execSync('git add .', {cwd: root, stdio: execStdio});
  const initialCommitOutput = childProcess
    .execSync('git commit -m "Initial commit"', {
      cwd: root,
      stdio: execStdio,
    })
    .toString();
  const initialCommitHash = parseGitCommitMessageHash(initialCommitOutput);

  // change file 2
  fs.writeFileSync(file2, 'module.exports = "two-rev"');
  childProcess.execSync('git add .', {cwd: root, stdio: execStdio});
  const changeFile2Hash = parseGitCommitMessageHash(
    childProcess
      .execSync('git commit -m "Change file 2"', {
        cwd: root,
        stdio: execStdio,
      })
      .toString(),
  );

  // change file 3
  fs.writeFileSync(file3, 'module.exports = "three-rev"');
  childProcess.execSync('git add .', {cwd: root, stdio: execStdio});
  const changeFile3Hash = parseGitCommitMessageHash(
    childProcess
      .execSync('git commit -m "Change file 3"', {
        cwd: root,
        stdio: execStdio,
      })
      .toString(),
  );

  // change the lockfile
  const yarnLockFileContentsAtEnd = `
# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 8
  cacheKey: 10c0

"lodash@npm:^4.17.21":
  version: 4.17.21
  resolution: "lodash@npm:4.17.21"
  checksum: 10c0/d8cbea072bb08655bb4c989da418994b073a608dffa608b09ac04b43a791b12aeae7cd7ad919aa4c925f33b48490b5cfe6c1f71d827956071dae2e7bb3a6b74c
  languageName: node
  linkType: hard

"sample_repository@workspace:.":
  version: 0.0.0-use.local
  resolution: "sample_repository@workspace:."
  dependencies:
    lodash: "npm:^4.17.21"
  languageName: unknown
  linkType: soft

`.trim();
  fs.writeFileSync(path.join(root, 'yarn.lock'), yarnLockFileContentsAtEnd);
  // commit the changes
  childProcess.execSync('git add .', {cwd: root, stdio: execStdio});
  const changeLockfileHash = parseGitCommitMessageHash(
    childProcess
      .execSync('git commit -m "Change lockfile"', {
        cwd: root,
        stdio: execStdio,
      })
      .toString(),
  );

  return {
    root,
    file1,
    file2,
    file3,
    initialCommitHash,
    changeFile2Hash,
    changeFile3Hash,
    changeLockfileHash,
    yarnStateFileContents,
  };
}

function findSnapshotPath(cacheDir: string): string {
  const filesInCache = fs.readdirSync(cacheDir);
  const snapshotFileName = filesInCache.find(
    (file) =>
      file.startsWith('snapshot-') && !file.endsWith('.native-snapshot.txt'),
  );
  if (snapshotFileName == null) {
    throw new Error('No snapshot file found in cache');
  }
  return path.join(cacheDir, snapshotFileName);
}

describe('vcs cache', () => {
  before(async function () {
    this.timeout(10000);
    // Warm up worker farm so that the first test doesn't account for this time.
    await workerFarm.callAllWorkers('ping', []);
  });

  afterEach(() => {
    try {
      fs.rmSync(getTemporaryDirectory(), {recursive: true});
    } catch (err) {
      // ignore
    }
  });

  it('should write a correct snapshot into the cache', async () => {
    const {root, file1, initialCommitHash} = setupGitRepository();

    // checkout the initial commit
    childProcess.execSync('git checkout ' + initialCommitHash, {
      cwd: root,
      stdio: execStdio,
    });

    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });

    // bundle the file
    const result = await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });
    assertBundles(result, [
      {name: 'file1.js', assets: ['file1.js', 'file2.js', 'file3.js']},
    ]);

    // check that the cache directory was created
    const cacheDir = path.join(root, '.parcel-cache');
    assert.ok(fs.existsSync(cacheDir));

    // check that the snapshot file was created
    const snapshotPath = findSnapshotPath(cacheDir);
    assert.ok(fs.existsSync(snapshotPath));

    // check that the snapshot file is valid
    const snapshot = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));
    assert.equal(snapshot.vcsState.gitHash.slice(0, 7), initialCommitHash);
    assert.equal(snapshot.vcsState.dirtyFiles.length, 0);
    assert.equal(snapshot.vcsState.yarnStates.length, 1);
  });

  it('should be able to list changes between revisions', async () => {
    const {
      root,
      file1,
      file2,
      file3,
      initialCommitHash,
      changeFile2Hash,
      changeFile3Hash,
    } = setupGitRepository();

    // checkout the initial commit
    childProcess.execSync('git checkout ' + initialCommitHash, {
      cwd: root,
      stdio: execStdio,
    });

    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });

    // bundle the file
    const result = await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });
    assertBundles(result, [
      {name: 'file1.js', assets: ['file1.js', 'file2.js', 'file3.js']},
    ]);

    // checkout the next commit
    childProcess.execSync('git checkout ' + changeFile2Hash, {
      cwd: root,
      stdio: execStdio,
    });

    // query the fs for changes
    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      assert.equal(changes.length, 1);
      assert.equal(changes[0].path, file2);
      assert.equal(changes[0].type, 'update');
    }

    // checkout the next commit
    childProcess.execSync('git checkout ' + changeFile3Hash, {
      cwd: root,
      stdio: execStdio,
    });

    // query the fs for changes
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      changes.sort((a, b) => a.path.localeCompare(b.path));
      assert.equal(changes.length, 2);
      assert.equal(changes[0].path, file2);
      assert.equal(changes[0].type, 'update');
      assert.equal(changes[1].path, file3);
      assert.equal(changes[1].type, 'update');
    }
  });

  it('should be able to detect files that have been modified outside of git', async () => {
    const {root, file1, file2} = setupGitRepository();

    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });

    // bundle the file
    const result = await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });
    assertBundles(result, [
      {name: 'file1.js', assets: ['file1.js', 'file2.js', 'file3.js']},
    ]);

    // remove file2
    fs.rmSync(file2, {force: true});

    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      assert.equal(changes.length, 1);
      assert.equal(changes[0].path, file2);
      assert.equal(changes[0].type, 'delete');
    }
  });

  it('if a build is made over a dirty state, it should be able to detect changes on the next build', async () => {
    const {root, file1, file2, changeLockfileHash} = setupGitRepository();

    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });

    // update file2 outside of git
    const newFile2Contents = 'module.exports = "two-rev-outside-git"';
    fs.writeFileSync(file2, newFile2Contents);

    // bundle the file
    const result = await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });
    assertBundles(result, [
      {name: 'file1.js', assets: ['file1.js', 'file2.js', 'file3.js']},
    ]);

    // check the snapshot tracks the file2 state
    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));
    const snapshot = JSON.parse(fs.readFileSync(snapshotPath, 'utf8'));
    assert.equal(snapshot.vcsState.gitHash.slice(0, 7), changeLockfileHash);
    assert.equal(snapshot.vcsState.dirtyFiles.length, 1);

    assert.equal(
      snapshot.vcsState.dirtyFiles[0].path,
      path.relative(root, file2),
    );
    assert(snapshot.vcsState.dirtyFiles[0].hash != null);

    // revert the file2 changes
    childProcess.execSync('git checkout -- ' + file2, {
      cwd: root,
      stdio: execStdio,
    });

    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      assert.equal(changes.length, 1);
      assert.equal(changes[0].path, file2);
      assert.equal(changes[0].type, 'update');
    }
  });

  it('can detect changes to node_modules', async () => {
    const {root, file1, changeFile3Hash, changeLockfileHash} =
      setupGitRepository();

    // checkout change 3, before the yarn.lock change
    childProcess.execSync('git checkout ' + changeFile3Hash, {
      cwd: root,
      stdio: execStdio,
    });

    // bundle the file
    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });
    await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });

    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));

    // there are no changes yet
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      assert.equal(changes.length, 0);
    }

    // checkout the yarn.lock changes
    childProcess.execSync('git checkout ' + changeLockfileHash, {
      cwd: root,
      stdio: execStdio,
    });

    // there are changes now to all files under node_modules/lodash
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      changes.sort((a, b) => a.path.localeCompare(b.path));
      assert.equal(changes.length, 5);

      // 5 changes:
      // * the lock file
      // * plus delete/create for each of the files under node_modules/lodash

      const lodashDir = path.join(root, 'node_modules', 'lodash');
      assert.equal(changes[0].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[0].type, 'delete');

      assert.equal(changes[1].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[1].type, 'create');

      assert.equal(changes[2].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[2].type, 'delete');

      assert.equal(changes[3].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[3].type, 'create');

      assert.equal(changes[4].path, path.join(root, 'yarn.lock'));
      assert.equal(changes[4].type, 'update');
    }
  });

  it('can detect changes to node_modules that are untracked by git if the build is done on a clean state', async () => {
    const {root, file1} = setupGitRepository();

    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });
    await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });

    // the user modifies yarn.lock AFTER building ; and the change is untracked
    const yarnLockFileContents = `
# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 8
  cacheKey: 10c0

"lodash@npm:^50":
  version: 50.0.0
  resolution: "lodash@npm:50.0.0"
  checksum: 10c0/f5f6d3d87503c3f1db27d49b30a00bb38dc1bd9de716c5febe8970259cc7b447149a0e320452ccaf5996a7a4abd63d94df341bb91bd8d336584ad518d8eab144
  languageName: node
  linkType: hard

"sample_repository@workspace:.":
  version: 0.0.0-use.local
  resolution: "sample_repository@workspace:."
  dependencies:
    lodash: "npm:^50"
  languageName: unknown
  linkType: soft

`.trim();
    fs.writeFileSync(path.join(root, 'yarn.lock'), yarnLockFileContents);
    const yarnStateFileContents = `
# Warning: This file is automatically generated. Removing it is fine, but will
# cause your node_modules installation to become invalidated.

__metadata:
  version: 1
  nmMode: classic

"lodash@npm:50.0.0":
  locations:
    - "node_modules/lodash"

"sample_repository@workspace:.":
  locations:
    - ""

  `.trim();
    fs.mkdirSync(path.join(root, 'node_modules'), {recursive: true});
    fs.writeFileSync(
      path.join(root, 'node_modules', '.yarn-state.yml'),
      yarnStateFileContents,
    );

    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      changes.sort((a, b) => a.path.localeCompare(b.path));
      assert.equal(changes.length, 5);

      const lodashDir = path.join(root, 'node_modules', 'lodash');
      assert.equal(changes[0].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[0].type, 'delete');

      assert.equal(changes[1].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[1].type, 'create');

      assert.equal(changes[2].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[2].type, 'delete');

      assert.equal(changes[3].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[3].type, 'create');

      assert.equal(changes[4].path, path.join(root, 'yarn.lock'));
      assert.equal(changes[4].type, 'update');
    }
  });

  it('can detect changes to node_modules that are untracked by git if the build is done on a dirty state', async () => {
    const {
      root,
      file1,
      yarnStateFileContents: initialYarnStateFileContents,
    } = setupGitRepository();

    // the user modifies yarn.lock BEFORE building ; and the change is untracked
    const yarnLockFileContents = `
# This file is generated by running "yarn install" inside your project.
# Manual changes might be lost - proceed with caution!

__metadata:
  version: 8
  cacheKey: 10c0

"lodash@npm:^50":
  version: 50.0.0
  resolution: "lodash@npm:50.0.0"
  checksum: 10c0/f5f6d3d87503c3f1db27d49b30a00bb38dc1bd9de716c5febe8970259cc7b447149a0e320452ccaf5996a7a4abd63d94df341bb91bd8d336584ad518d8eab144
  languageName: node
  linkType: hard

"sample_repository@workspace:.":
  version: 0.0.0-use.local
  resolution: "sample_repository@workspace:."
  dependencies:
    lodash: "npm:^50"
  languageName: unknown
  linkType: soft

`.trim();
    fs.writeFileSync(path.join(root, 'yarn.lock'), yarnLockFileContents);
    const yarnStateFileContents = `
# Warning: This file is automatically generated. Removing it is fine, but will
# cause your node_modules installation to become invalidated.

__metadata:
  version: 1
  nmMode: classic

"lodash@npm:50.0.0":
  locations:
    - "node_modules/lodash"

"sample_repository@workspace:.":
  locations:
    - ""

  `.trim();
    fs.mkdirSync(path.join(root, 'node_modules'), {recursive: true});
    fs.writeFileSync(
      path.join(root, 'node_modules', '.yarn-state.yml'),
      yarnStateFileContents,
    );

    // build
    const vcsFS = new NodeVCSAwareFS({
      gitRepoPath: root,
      excludePatterns: [],
      logEventDiff: null,
    });
    await bundle(file1, {
      inputFS: vcsFS,
      outputFS: vcsFS,
      shouldDisableCache: false,
      featureFlags: {
        useLmdbJsLite: true,
        vcsMode: 'NEW',
      },
    });

    // revert the changes
    childProcess.execSync('git checkout -- .', {
      cwd: root,
      stdio: execStdio,
    });
    fs.writeFileSync(
      path.join(root, 'node_modules', '.yarn-state.yml'),
      initialYarnStateFileContents,
    );

    const snapshotPath = findSnapshotPath(path.join(root, '.parcel-cache'));
    {
      const changes = await vcsFS.getEventsSince(root, snapshotPath, {});
      changes.sort((a, b) => a.path.localeCompare(b.path));
      assert.equal(changes.length, 5);

      const lodashDir = path.join(root, 'node_modules', 'lodash');
      assert.equal(changes[0].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[0].type, 'delete');

      assert.equal(changes[1].path, path.join(lodashDir, 'file1.js'));
      assert.equal(changes[1].type, 'create');

      assert.equal(changes[2].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[2].type, 'delete');

      assert.equal(changes[3].path, path.join(lodashDir, 'src', 'file2.js'));
      assert.equal(changes[3].type, 'create');

      assert.equal(changes[4].path, path.join(root, 'yarn.lock'));
      assert.equal(changes[4].type, 'update');
    }
  });
});
