/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export interface AtlaspackNapiOptions {
  fs?: object
  options: object
  packageManager?: object
  threads?: number
  napiWorkerPool: object
}
export interface CompiledCssInJsConfigPlugin {
  configPath?: string
  importReact?: boolean
  nonce?: string
  importSources?: Array<string>
  optimizeCss?: boolean
  extensions?: Array<string>
  addComponentName?: boolean
  processXcss?: boolean
  increaseSpecificity?: boolean
  sortAtRules?: boolean
  sortShorthand?: boolean
  classHashPrefix?: string
  flattenMultipleSelectors?: boolean
  extract?: boolean
  ssr?: boolean
  unsafeReportSafeAssetsForMigration?: boolean
  unsafeUseSafeAssets?: boolean
  unsafeSkipPattern?: string
}
export interface CompiledCssInJsPluginInput {
  filename: string
  projectRoot: string
  isSource: boolean
  sourceMaps: boolean
  config: CompiledCssInJsConfigPlugin
}
export interface CompiledCssInJsPluginResult {
  code: string
  map?: string
  styleRules: Array<string>
  diagnostics: Array<JsDiagnostic>
  bailOut: boolean
}
export interface Entry {
  key: string
  value: Buffer
}
export interface FileNameCreateInvalidation {
  fileName: string
  aboveFilePath: string
}
export interface FilePathCreateInvalidation {
  filePath: string
}
export interface FileSystem {
  fs?: JsFileSystemOptions
  includeNodeModules?: NapiSideEffectsVariants
  conditions?: number
  moduleDirResolver?: (...args: any[]) => any
  mode: number
  entries?: number
  extensions?: Array<string>
  packageExports: boolean
  typescript?: boolean
  reduceStringCreation?: boolean
}
export interface GlobCreateInvalidation {
  glob: string
}
export interface InlineRequiresOptimizerInput {
  code: string
  sourceMaps: boolean
  ignoreModuleIds: Array<string>
}
export interface InlineRequiresOptimizerResult {
  code: string
  sourceMap?: string
}
/** NAPI-compatible code highlight for JavaScript */
export interface JsCodeHighlight {
  message?: string
  loc: JsSourceLocation
}
/** NAPI-compatible diagnostic for JavaScript */
export interface JsDiagnostic {
  message: string
  codeHighlights?: Array<JsCodeHighlight>
  hints?: Array<string>
  showEnvironment: boolean
  severity: string
  documentationUrl?: string
}
export interface JsFileSystemOptions {
  canonicalize: (...args: any[]) => any
  read: (...args: any[]) => any
  isFile: (...args: any[]) => any
  isDir: (...args: any[]) => any
  includeNodeModules?: NapiSideEffectsVariants
}
export interface JsInvalidations {
  invalidateOnFileChange: Array<string>
  invalidateOnFileCreate: Array<FilePathCreateInvalidation | FileNameCreateInvalidation | GlobCreateInvalidation>
  invalidateOnStartup: boolean
}
/** NAPI-compatible source location for JavaScript */
export interface JsSourceLocation {
  startLine: number
  startCol: number
  endLine: number
  endCol: number
}
export interface LmdbOptions {
  /** The database directory path */
  path: string
  /**
   * If enabled, the database writer will set the following flags:
   *
   * * MAP_ASYNC - "use asynchronous msync when MDB_WRITEMAP is used"
   * * NO_SYNC - "don't fsync after commit"
   * * NO_META_SYNC - "don't fsync metapage after commit"
   *
   * `MDB_WRITEMAP` is on by default.
   */
  asyncWrites: boolean
  /**
   * The mmap size, this corresponds to [`mdb_env_set_mapsize`](http://www.lmdb.tech/doc/group__mdb.html#gaa2506ec8dab3d969b0e609cd82e619e5)
   * if this isn't set it'll default to around 10MB.
   */
  mapSize?: number
}
export interface Replacement {
  from: string
  to: string
}
export interface ResolveOptions {
  filename: string
  specifierType: string
  parent: string
  packageConditions?: Array<string>
}
export interface ResolveResult {
  resolution: unknown
  invalidateOnFileChange: Array<string>
  invalidateOnFileCreate: Array<FilePathCreateInvalidation | FileNameCreateInvalidation | GlobCreateInvalidation>
  query?: string
  sideEffects: boolean
  error: unknown
  moduleType: number
}
export interface TokensConfig {
  filename: string
  projectRoot: string
  isSource: boolean
  sourceMaps: boolean
  tokensOptions: TokensPluginOptions
}
export interface TokensPluginOptions {
  tokenDataPath: string
  shouldUseAutoFallback: boolean
  shouldForceAutoFallback: boolean
  forceAutoFallbackExemptions: Array<string>
  defaultTheme: string
}
export interface TokensPluginResult {
  code: string
  map?: string
  diagnostics: Array<JsDiagnostic>
}
/** Add an environment to the global manager */
export declare function addEnvironment(environment: unknown): void
export declare function applyCompiledCssInJsPlugin(rawCode: Buffer, input: CompiledCssInJsPluginInput): object
/** Apply the tokens transformation plugin to the given code asynchronously */
export declare function applyTokensPlugin(rawCode: Buffer, config: TokensConfig): object
export declare function atlaspackNapiBuildAssetGraph(atlaspackNapi: AtlaspackNapi): object
export declare function atlaspackNapiCompleteSession(atlaspackNapi: AtlaspackNapi): object
export declare function atlaspackNapiCreate(napiOptions: AtlaspackNapiOptions, lmdb: LMDBJsLite): object
export declare function atlaspackNapiLoadBundleGraph(atlaspackNapi: AtlaspackNapi, nodes: Array<object>, edges: Array<[number, number]>): object
export declare function atlaspackNapiRespondToFsEvents(atlaspackNapi: AtlaspackNapi, options: object): object
export declare function closeMonitoring(): void
export declare function createAssetId(params: unknown): string
export declare function createDependencyId(params: unknown): string
export declare function createEnvironmentId(params: unknown): string
export declare function determineJsxConfiguration(filePath: string, isSource: boolean, config: object, projectRoot: string): unknown
export declare function findAncestorFile(filenames: Array<string>, from: string, root: string): string | null
export declare function findFirstFile(names: Array<string>): string | null
export declare function findNodeModule(module: string, from: string): string | null
/** Get an array of all environments */
export declare function getAllEnvironments(): Array<unknown>
export declare function getAvailableThreads(): number
/** Get environment by ID */
export declare function getEnvironment(id: string): unknown
export declare function getEventsSince(repoPath: string, vcsStateSnapshot: unknown, newRev?: string | undefined | null): object
export declare function getNativeMemoryStats(): NativeMemoryStats | null
export declare function getVcsStateSnapshot(path: string, excludePatterns: Array<string>): object
export declare function hashBuffer(buf: Buffer): string
export declare function hashCode(rawCode: string): string
export declare function hashString(s: string): string
export declare function initializeMonitoring(): void
export declare function initTracingSubscriber(): void
export declare function isSafeFromJs(hash: string, configPath: string): boolean
/** Called on the worker thread to create a reference to the NodeJs worker */
export declare function newNodejsWorker(worker: object): JsTransferable
export declare function optimizeImage(kind: string, buf: Buffer): Buffer
export declare function performStringReplacements(input: string, replacements: Array<Replacement>): string
export declare function resetMemoryTracking(): void
export declare function runInlineRequiresOptimizer(input: InlineRequiresOptimizerInput): InlineRequiresOptimizerResult
/** Runs in the rayon thread pool */
export declare function runInlineRequiresOptimizerAsync(input: InlineRequiresOptimizerInput): object
export declare function sampleNativeMemory(): void
/** Overwrite all environments with a new set of environments */
export declare function setAllEnvironments(environments: unknown): void
export declare function transform(opts: object): unknown
export declare function transformAsync(opts: object): object
export class AtlaspackTracer {
  constructor()
  enter(label: string): SpanId
  exit(id: SpanId): void
}
export class Hash {
  constructor()
  writeString(s: string): void
  writeBuffer(buf: Buffer): void
  finish(): string
}
export type LMDB = Lmdb
export class Lmdb {
  constructor(options: LMDBOptions)
  get(key: string): Promise<Buffer | null | undefined>
  hasSync(key: string): boolean
  keysSync(skip: number, limit: number): Array<string>
  getSync(key: string): Buffer | null
  getManySync(keys: Array<string>): Array<Buffer | undefined | null>
  putMany(entries: Array<Entry>): Promise<void>
  put(key: string, data: Buffer): Promise<void>
  delete(key: string): Promise<void>
  putNoConfirm(key: string, data: Buffer): void
  startReadTransaction(): void
  commitReadTransaction(): void
  startWriteTransaction(): Promise<void>
  commitWriteTransaction(): Promise<void>
  compact(targetPath: string): void
}
export type LMDBJsLite = LmdbJsLite
export class LmdbJsLite {
  constructor(options: LmdbOptions)
  get(key: string): Promise<Buffer | null | undefined>
  hasSync(key: string): boolean
  keysSync(skip: number, limit: number): Array<string>
  getSync(key: string): Buffer | null
  getManySync(keys: Array<string>): Array<Buffer | undefined | null>
  putMany(entries: Array<Entry>): Promise<void>
  put(key: string, data: Buffer): Promise<void>
  putNoConfirm(key: string, data: Buffer): void
  delete(key: string): Promise<void>
  startReadTransaction(): void
  commitReadTransaction(): void
  startWriteTransaction(): Promise<void>
  commitWriteTransaction(): Promise<void>
  /** Compact the database to the target path */
  compact(targetPath: string): void
}
export class Resolver {
  constructor(projectRoot: string, options: FileSystem)
  resolve(options: ResolveOptions): ResolveResult
  resolveAsync(): object
  resolveAsync(options: ResolveOptions): object
  getInvalidations(path: string): JsInvalidations
  getInvalidations(path: string): JsInvalidations
}
export type JsSourceMap = SourceMap
export class SourceMap {
  constructor(projectRoot: string, buffer?: Buffer | undefined | null)
  addSource(source: string): number
  getSource(sourceIndex: number): string
  getSources(): Array<string>
  getSourcesContent(): Array<string>
  getSourceIndex(source: string): number
  setSourceContentBySource(source: string, sourceContent: string): void
  getSourceContentBySource(source: string): string
  addName(name: string): number
  getName(nameIndex: number): string
  getNames(): Array<string>
  getNameIndex(name: string): number
  getMappings(): unknown[]
  toBuffer(): Buffer
  addSourceMap(sourcemapObject: SourceMap, lineOffset: number): void
  addVLQMap(vlqMappings: string, sources: Array<string>, sourcesContent: Array<string>, names: Array<string>, lineOffset: number, columnOffset: number): void
  toVLQ(): object
  addIndexedMappings(mappings: JsTypedArray): void
  offsetLines(generatedLine: number, generatedLineOffset: number): void
  offsetColumns(generatedLine: number, generatedColumn: number, generatedColumnOffset: number): void
  addEmptyMap(source: string, sourceContent: string, lineOffset: number): void
  extends(originalSourcemap: SourceMap): void
  findClosestMapping(generatedLine: number, generatedColumn: number): object | null
  getProjectRoot(): string
}
