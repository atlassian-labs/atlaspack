#!/usr/bin/env node
/* eslint-disable no-console */
'use strict';

/**
 * Script to compare .swc.js and .babel.js output files generated by the
 * compiled CSS-in-JS transformers.
 *
 * Usage:
 *   node compare-compiled-output.js [--cwd <directory>] [--pattern <glob>] [--verbose] [--json]
 *
 * Options:
 *   --cwd <directory>   Working directory to search for files (default: current directory)
 *   --pattern <glob>    Only compare files matching pattern
 *   --verbose           Show detailed diffs for each file
 *   --json              Output results as JSON
 *   --summary           Only show summary statistics
 *   --no-format         Skip prettier formatting
 */

const fs = require('fs');
const path = require('path');
const {execSync} = require('child_process');

// Lazy-load prettier for performance (only load when needed)
let prettierInstance = null;
function getPrettier() {
  if (!prettierInstance) {
    try {
      prettierInstance = require('prettier');
    } catch (e) {
      return null;
    }
  }
  return prettierInstance;
}

// Required imports to be present in files for comparison
const REQUIRED_IMPORTS = ['@atlaskit/css', '@compiled/react'];

function parseArgs(args) {
  const options = {
    cwd: process.cwd(),
    pattern: null,
    verbose: false,
    json: false,
    summary: false,
    format: true,
  };

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];

    if (arg === '--cwd') {
      options.cwd = args[++i];
    } else if (arg.startsWith('--cwd=')) {
      options.cwd = arg.slice(6);
    } else if (arg === '--pattern') {
      options.pattern = args[++i];
    } else if (arg.startsWith('--pattern=')) {
      options.pattern = arg.slice(10);
    } else if (arg === '--verbose') {
      options.verbose = true;
    } else if (arg === '--json') {
      options.json = true;
    } else if (arg === '--summary') {
      options.summary = true;
    } else if (arg === '--no-format') {
      options.format = false;
    }
  }

  return options;
}

/**
 * Check if a file contains any of the required imports.
 * Files without @atlaskit/css or @compiled/react are skipped.
 */
function hasRequiredImports(code) {
  return REQUIRED_IMPORTS.some((importPath) => code.includes(importPath));
}

/**
 * Strip comments from code for comparison purposes.
 * Removes both single-line and multi-line comments.
 */
function stripComments(code) {
  // Remove multi-line comments (/* ... */)
  let result = code.replace(/\/\*[\s\S]*?\*\//g, '');

  // Remove single-line comments (//)
  // Only match // that is:
  // 1. At the start of a line (with optional whitespace), OR
  // 2. Preceded by whitespace (not inside a URL or string)
  // This avoids stripping URLs like https://example.com//path
  result = result.replace(/^(\s*)\/\/.*$/gm, '$1'); // Comments at start of line
  result = result.replace(/(\s)\/\/(?!\/).*$/gm, '$1'); // Comments after whitespace (but not /// which might be doc comments in the middle of something)

  return result;
}

// Prettier options for consistent formatting
const PRETTIER_OPTIONS = {
  parser: 'typescript',
  singleQuote: true,
  trailingComma: 'all',
  printWidth: 120,
};

/**
 * Format code using prettier with TypeScript parser (async version).
 * Uses prettier's Node API for speed (avoids CLI overhead).
 * Falls back to original code if prettier fails.
 */
async function formatWithPrettierAsync(filePath, code) {
  const prettier = getPrettier();
  if (!prettier) {
    // Fallback to CLI if prettier not available as module
    return formatWithPrettierCLI(code);
  }

  try {
    return await prettier.format(code, PRETTIER_OPTIONS);
  } catch (prettierError) {
    // Log error for debugging
    console.warn(
      `  [prettier failed: ${prettierError.message?.split('\n')[0] || 'unknown error'}]`,
    );
    // Return original code if prettier fails
    return code;
  }
}

// Batch size for parallel processing (limit to avoid memory issues)
const BATCH_SIZE = 100;

/**
 * Batch format multiple code strings with prettier in parallel.
 * Processes in batches to avoid memory issues with large file sets.
 */
async function formatBatchWithPrettier(codeArray) {
  const prettier = getPrettier();
  if (!prettier) {
    // Fallback to sequential CLI calls
    return codeArray.map((code) => formatWithPrettierCLI(code));
  }

  const results = [];

  // Process in batches to limit memory usage
  for (let i = 0; i < codeArray.length; i += BATCH_SIZE) {
    const batch = codeArray.slice(i, i + BATCH_SIZE);

    try {
      // Format batch in parallel
      const batchResults = await Promise.all(
        batch.map(async (code) => {
          try {
            return await prettier.format(code, PRETTIER_OPTIONS);
          } catch (e) {
            return code; // Return original on error
          }
        }),
      );
      results.push(...batchResults);
    } catch (e) {
      // Fallback to sequential for this batch
      for (const code of batch) {
        results.push(formatWithPrettierCLI(code));
      }
    }

    // Allow GC between batches
    if (i + BATCH_SIZE < codeArray.length) {
      await new Promise((resolve) => setImmediate(resolve));
    }
  }

  return results;
}

/**
 * Fallback: Format code using prettier CLI via stdin/stdout.
 */
function formatWithPrettierCLI(code) {
  try {
    const formatted = execSync(
      'npx prettier --parser typescript --no-config --single-quote --trailing-comma all --print-width 120',
      {
        input: code,
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'pipe'],
        timeout: 30000,
        maxBuffer: 10 * 1024 * 1024,
      },
    );
    return formatted;
  } catch (prettierError) {
    const errorMsg =
      prettierError.stderr || prettierError.message || 'unknown error';
    console.warn(`  [prettier CLI failed: ${errorMsg.split('\n')[0]}]`);
    return code;
  }
}

function findFiles(dir, pattern, extension) {
  const results = [];

  try {
    // Use find command for efficiency
    const cmd = `find "${dir}" -name "*${extension}" -type f 2>/dev/null`;
    const output = execSync(cmd, {
      encoding: 'utf8',
      maxBuffer: 50 * 1024 * 1024,
    });
    const files = output.trim().split('\n').filter(Boolean);

    for (const file of files) {
      if (pattern && !file.includes(pattern)) {
        continue;
      }
      results.push(file);
    }
  } catch (e) {
    // Fallback to recursive directory traversal
    const walkDir = (currentDir) => {
      const entries = fs.readdirSync(currentDir, {withFileTypes: true});
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        if (
          entry.isDirectory() &&
          !entry.name.startsWith('.') &&
          entry.name !== 'node_modules'
        ) {
          walkDir(fullPath);
        } else if (entry.isFile() && entry.name.endsWith(extension)) {
          if (!pattern || fullPath.includes(pattern)) {
            results.push(fullPath);
          }
        }
      }
    };
    walkDir(dir);
  }

  return results;
}

/**
 * Normalize lines containing `var _[0-9]* = ` or `const _[0-9]* = ` by removing
 * the variable prefix and sorting those lines. This allows comparison to ignore
 * the order of temporary variable declarations which may differ between SWC and Babel.
 * Also handles multiline declarations where `const _ =` is on one line and the value on the next.
 */
function normalizeVarDeclarations(code) {
  const lines = code.split('\n');
  // Match both var and const declarations with optional numeric suffixes (e.g., const _ =, const _0 =, const _12 =)
  const varPatternInline = /^(var|const) _[0-9]* = .+/; // Single line: const _ = 'value';
  const varPatternMultilineStart = /^(var|const) _[0-9]* =$/; // Multiline start: const _ =

  const normalizedLines = [];
  const varLines = [];
  let pendingMultiline = false;
  let multilineValue = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    if (pendingMultiline) {
      // This is the continuation of a multiline declaration
      multilineValue = line.trim();
      varLines.push(multilineValue);
      pendingMultiline = false;
      continue;
    }

    if (varPatternMultilineStart.test(line)) {
      // Start of multiline declaration (e.g., "const _ =")
      pendingMultiline = true;
      continue;
    }

    if (varPatternInline.test(line)) {
      // Single line declaration - remove the `var _N = ` or `const _N = ` prefix
      const normalized = line.replace(/^(var|const) _[0-9]* = /, '');
      varLines.push(normalized);
    } else {
      // If we have collected var lines, sort and flush them
      if (varLines.length > 0) {
        varLines.sort();
        normalizedLines.push(...varLines);
        varLines.length = 0;
      }
      normalizedLines.push(line);
    }
  }

  // Flush any remaining var lines
  if (varLines.length > 0) {
    varLines.sort();
    normalizedLines.push(...varLines);
  }

  return normalizedLines.join('\n');
}

/**
 * Empty the array contents inside <CS>{[...]}</CS> to normalize.
 * This is because the order of style references varies between SWC and Babel.
 */
function normalizeCSArrays(code) {
  // Match <CS>{[...anything...]}</CS> and replace with <CS>{[]}</CS>
  // Handle both single-line and multi-line arrays
  // Single-line: <CS>{[_1, _2, _3]}</CS>
  // Multi-line:  <CS>\n  {[\n    _1,\n    _2,\n  ]}\n</CS>
  return code.replace(/<CS>\s*\{[\s\S]*?\}\s*<\/CS>/g, '<CS>{[]}</CS>');
}

/**
 * Sort class names inside className string constants.
 * E.g., '_b _a _c' becomes '_a _b _c'
 */
function normalizeClassNameStrings(code) {
  // Match className strings that contain space-separated class names starting with _
  // Pattern: '_{class} _{class} ...' or "_{class} _{class} ..."
  return code.replace(/'(_[a-z0-9]+(?: _[a-z0-9]+)+)'/g, (match, classes) => {
    const sorted = classes.split(' ').sort().join(' ');
    return `'${sorted}'`;
  });
}

/**
 * Normalize redundant destructuring patterns.
 * E.g., { isArchiveOption: isArchiveOption } becomes { isArchiveOption }
 * This handles the difference between SWC and Babel destructuring output.
 */
function normalizeDestructuring(code) {
  // Match patterns like `identifier: identifier` where both are the same
  // This handles destructuring like { foo: foo, bar: bar }
  return code.replace(/\b([a-zA-Z_$][a-zA-Z0-9_$]*): \1\b/g, '$1');
}

/**
 * Remove jsx-runtime import lines as they can vary between SWC and Babel
 * but are semantically equivalent.
 * E.g., removes: import { jsx } from 'react/jsx-runtime';
 */
function removeJsxRuntimeImports(code) {
  // Remove import lines containing react/jsx-runtime
  return code.replace(
    /^import\s+\{[^}]*\}\s+from\s+['"]react\/jsx-runtime['"];?\s*$/gm,
    '',
  );
}

/**
 * Normalize multi-line imports to single line.
 * Handles cases where SWC outputs imports across multiple lines.
 */
function normalizeImports(code) {
  // Match import statements that span multiple lines and collapse them
  // Pattern: import {\n  item1,\n  item2,\n} from 'module';
  return code.replace(/import\s*\{\s*\n([^}]+)\}\s*from/g, (match, items) => {
    // Collapse the items to a single line, removing extra whitespace
    const collapsedItems = items
      .split('\n')
      .map((line) => line.trim())
      .filter((line) => line.length > 0)
      .join(' ')
      .replace(/,\s*/g, ', ')
      .replace(/,\s*$/, ''); // Remove trailing comma
    return `import { ${collapsedItems} } from`;
  });
}

function normalizeCode(code) {
  // Strip comments for comparison
  let result = stripComments(code);

  // Remove jsx-runtime imports early (can vary between SWC and Babel)
  result = removeJsxRuntimeImports(result);

  // Normalize whitespace and formatting differences that don't affect functionality
  result = result
    // Normalize line endings
    .replace(/\r\n/g, '\n')
    // Remove leading whitespace from lines (normalize indentation differences after comment stripping)
    .replace(/^[ \t]+/gm, '')
    // Remove trailing whitespace
    .replace(/[ \t]+$/gm, '')
    // Normalize multiple blank lines to single
    .replace(/\n{3,}/g, '\n\n')
    // Remove empty lines completely for cleaner comparison
    .replace(/^\s*\n/gm, '')
    // Trim leading/trailing whitespace
    .trim();

  // Normalize var declarations (remove `var _N = ` and sort those lines)
  result = normalizeVarDeclarations(result);

  // Empty CS arrays to ignore ordering differences
  result = normalizeCSArrays(result);

  // Sort class names in className strings
  result = normalizeClassNameStrings(result);

  // Normalize redundant destructuring (e.g., { foo: foo } -> { foo })
  result = normalizeDestructuring(result);

  return result;
}

function computeDiff(swcCode, babelCode) {
  const swcLines = swcCode.split('\n');
  const babelLines = babelCode.split('\n');

  const swcOnly = [];
  const babelOnly = [];
  const common = [];

  const babelSet = new Set(babelLines);
  const swcSet = new Set(swcLines);

  for (const line of swcLines) {
    if (babelSet.has(line)) {
      common.push(line);
    } else {
      swcOnly.push(line);
    }
  }

  for (const line of babelLines) {
    if (!swcSet.has(line)) {
      babelOnly.push(line);
    }
  }

  return {
    swcOnly,
    babelOnly,
    common,
    identical:
      swcOnly.length === 0 &&
      babelOnly.length === 0 &&
      swcLines.length === babelLines.length,
  };
}

/**
 * Generate a unified diff format string and write it to a .diff file.
 */
function writeDiffFile(basePath, swcFile, babelFile, diff) {
  const diffPath = basePath + '.diff';

  const lines = [];
  lines.push(`--- ${path.basename(babelFile)} (Babel)`);
  lines.push(`+++ ${path.basename(swcFile)} (SWC)`);
  lines.push('');

  if (diff.babelOnly.length > 0) {
    lines.push('=== Lines only in Babel output ===');
    for (const line of diff.babelOnly) {
      lines.push(`- ${line}`);
    }
    lines.push('');
  }

  if (diff.swcOnly.length > 0) {
    lines.push('=== Lines only in SWC output ===');
    for (const line of diff.swcOnly) {
      lines.push(`+ ${line}`);
    }
    lines.push('');
  }

  lines.push(`=== Summary ===`);
  lines.push(`Common lines: ${diff.common.length}`);
  lines.push(`Babel-only lines: ${diff.babelOnly.length}`);
  lines.push(`SWC-only lines: ${diff.swcOnly.length}`);

  try {
    fs.writeFileSync(diffPath, lines.join('\n'), 'utf8');
    return diffPath;
  } catch (e) {
    console.warn(`Failed to write diff file ${diffPath}: ${e.message}`);
    return null;
  }
}

async function main() {
  const options = parseArgs(process.argv.slice(2));
  const cwd = path.resolve(options.cwd);

  if (!options.json) {
    console.log('=== Compiled CSS-in-JS Output Comparison ===');
    console.log(`Directory: ${cwd}`);
    if (options.pattern) {
      console.log(`Pattern: ${options.pattern}`);
    }
    console.log('');
  }

  // Find all .swc.js files
  const swcFiles = findFiles(cwd, options.pattern, '.swc.js');

  if (swcFiles.length === 0) {
    if (options.json) {
      console.log(JSON.stringify({error: 'No .swc.js files found', files: []}));
    } else {
      console.log('No .swc.js files found.');
      console.log(
        'Make sure to run the build with ATLASPACK_EMIT_SWC_OUTPUT=true first.',
      );
    }
    return;
  }

  const results = {
    total: swcFiles.length,
    identical: 0,
    different: 0,
    missingBabel: 0,
    skipped: 0,
    files: [],
  };

  // First pass: collect all files that need processing
  const filesToProcess = [];
  for (const swcFile of swcFiles) {
    const basePath = swcFile.replace(/\.swc\.js$/, '');
    const babelFile = basePath + '.babel.js';
    const originalFile = basePath;
    const relativePath = path.relative(cwd, originalFile);

    const fileResult = {
      file: relativePath,
      swcFile: path.relative(cwd, swcFile),
      babelFile: path.relative(cwd, babelFile),
      status: 'unknown',
      diff: null,
    };

    if (!fs.existsSync(babelFile)) {
      fileResult.status = 'missing_babel';
      results.missingBabel++;
      results.files.push(fileResult);
      if (!options.summary && !options.json) {
        console.log(`[MISSING BABEL] ${relativePath}`);
      }
      continue;
    }

    // Read raw files first to check for required imports
    let swcCodeRaw = fs.readFileSync(swcFile, 'utf8');
    let babelCodeRaw = fs.readFileSync(babelFile, 'utf8');

    // Skip files that don't contain required imports
    if (!hasRequiredImports(swcCodeRaw) && !hasRequiredImports(babelCodeRaw)) {
      fileResult.status = 'skipped';
      results.skipped++;
      if (!options.summary && !options.json && options.verbose) {
        console.log(
          `[SKIPPED] ${relativePath} (no @atlaskit/css or @compiled/react)`,
        );
      }
      continue;
    }

    // Strip comments first so prettier can format consistently
    swcCodeRaw = stripComments(swcCodeRaw);
    babelCodeRaw = stripComments(babelCodeRaw);

    // Normalize destructuring BEFORE prettier so both have same length lines
    // (SWC outputs { foo: foo } which is longer than Babel's { foo })
    swcCodeRaw = normalizeDestructuring(swcCodeRaw);
    babelCodeRaw = normalizeDestructuring(babelCodeRaw);

    filesToProcess.push({
      swcFile,
      babelFile,
      basePath,
      relativePath,
      fileResult,
      swcCodeRaw,
      babelCodeRaw,
    });
  }

  // Second pass: batch format all files with prettier in batches
  if (options.format && filesToProcess.length > 0) {
    const totalPairs = filesToProcess.length;
    const batchSize = BATCH_SIZE / 2; // Divide by 2 since we have pairs

    if (!options.json && !options.summary) {
      console.log(
        `Formatting ${totalPairs} file pairs in batches of ${batchSize}...`,
      );
    }

    // Process files in batches to avoid memory issues
    for (let i = 0; i < filesToProcess.length; i += batchSize) {
      const batch = filesToProcess.slice(i, i + batchSize);
      const batchNum = Math.floor(i / batchSize) + 1;
      const totalBatches = Math.ceil(filesToProcess.length / batchSize);

      if (!options.json && !options.summary && totalBatches > 1) {
        process.stdout.write(`  Batch ${batchNum}/${totalBatches}...`);
      }

      // Collect code for this batch
      const batchCode = batch.flatMap((f) => [f.swcCodeRaw, f.babelCodeRaw]);

      // Format batch
      const formattedCode = await formatBatchWithPrettier(batchCode);

      // Distribute results back and write files
      for (let j = 0; j < batch.length; j++) {
        batch[j].swcCodeRaw = formattedCode[j * 2];
        batch[j].babelCodeRaw = formattedCode[j * 2 + 1];

        // Write formatted files back for human inspection
        fs.writeFileSync(batch[j].swcFile, batch[j].swcCodeRaw, 'utf8');
        fs.writeFileSync(batch[j].babelFile, batch[j].babelCodeRaw, 'utf8');
      }

      if (!options.json && !options.summary && totalBatches > 1) {
        console.log(' done');
      }

      // Allow GC between batches
      await new Promise((resolve) => setImmediate(resolve));
    }

    if (!options.json && !options.summary) {
      console.log('Formatting complete.');
      console.log('');
    }
  }

  // Third pass: compare all files
  for (const {
    swcFile,
    babelFile,
    basePath,
    relativePath,
    fileResult,
    swcCodeRaw,
    babelCodeRaw,
  } of filesToProcess) {
    // Normalize for comparison
    const swcCode = normalizeCode(swcCodeRaw);
    const babelCode = normalizeCode(babelCodeRaw);

    const diff = computeDiff(swcCode, babelCode);

    if (diff.identical) {
      fileResult.status = 'identical';
      results.identical++;
    } else {
      fileResult.status = 'different';
      fileResult.diff = {
        swcOnlyLines: diff.swcOnly.length,
        babelOnlyLines: diff.babelOnly.length,
        commonLines: diff.common.length,
      };
      results.different++;

      // Write diff to a .diff file as sibling to the source files
      const diffFile = writeDiffFile(basePath, swcFile, babelFile, diff);
      if (diffFile) {
        fileResult.diffFile = path.relative(cwd, diffFile);
      }

      if (!options.summary && !options.json) {
        console.log(`[DIFFERENT] ${relativePath}`);
        console.log(`  SWC-only lines: ${diff.swcOnly.length}`);
        console.log(`  Babel-only lines: ${diff.babelOnly.length}`);
        console.log(`  Common lines: ${diff.common.length}`);
        if (diffFile) {
          console.log(`  Diff file: ${path.relative(cwd, diffFile)}`);
        }

        if (options.verbose) {
          if (diff.swcOnly.length > 0 && diff.swcOnly.length <= 20) {
            console.log('  SWC-only:');
            for (const line of diff.swcOnly.slice(0, 10)) {
              console.log(`    + ${line}`);
            }
            if (diff.swcOnly.length > 10) {
              console.log(`    ... and ${diff.swcOnly.length - 10} more`);
            }
          }
          if (diff.babelOnly.length > 0 && diff.babelOnly.length <= 20) {
            console.log('  Babel-only:');
            for (const line of diff.babelOnly.slice(0, 10)) {
              console.log(`    - ${line}`);
            }
            if (diff.babelOnly.length > 10) {
              console.log(`    ... and ${diff.babelOnly.length - 10} more`);
            }
          }
        }
        console.log('');
      }
    }

    results.files.push(fileResult);
  }

  // Output results
  const comparedTotal = results.total - results.skipped;
  if (options.json) {
    console.log(JSON.stringify(results, null, 2));
  } else {
    console.log('');
    console.log('=== Summary ===');
    console.log(`Total files found: ${results.total}`);
    console.log(
      `Skipped (no @atlaskit/css or @compiled/react): ${results.skipped}`,
    );
    console.log(`Compared: ${comparedTotal}`);
    if (comparedTotal > 0) {
      console.log(
        `Identical: ${results.identical} (${((results.identical / comparedTotal) * 100).toFixed(1)}%)`,
      );
      console.log(
        `Different: ${results.different} (${((results.different / comparedTotal) * 100).toFixed(1)}%)`,
      );
    }
    console.log(`Missing Babel: ${results.missingBabel}`);

    if (results.different > 0) {
      console.log('');
      console.log('Files with differences:');
      for (const file of results.files) {
        if (file.status === 'different') {
          console.log(`  - ${file.file}`);
        }
      }
    }
  }

  // Exit with error code if there are differences
  if (results.different > 0 || results.missingBabel > 0) {
    process.exit(1);
  }
}

main().catch((e) => {
  console.error('Error:', e.message);
  process.exit(1);
});
