/* eslint-disable no-console */

const {execSync} = require('child_process');

const WORKSPACE_PATH = process.env.GITHUB_WORKSPACE ?? process.cwd();
const MAX_FILES = 15;
const BASE_REF = process.env.GITHUB_BASE_REF ?? 'main';

/**
 * Get the baseline commit SHA for comparison
 * @returns {string|null} The baseline commit SHA or null if not available
 */
function getBaselineCommit() {
  try {
    // Get the merge base between the base branch and current HEAD
    const mergeBase = execSync(`git merge-base origin/${BASE_REF} HEAD`, {
      encoding: 'utf8',
      cwd: WORKSPACE_PATH,
    }).trim();

    console.log(
      `Baseline commit: ${mergeBase} (merge base with origin/${BASE_REF})`,
    );
    return mergeBase;
  } catch (error) {
    console.error('Failed to get baseline commit:', error.message);
    return null;
  }
}

/**
 * Run type coverage and return the results
 * @param {string|null} commitSha - The commit SHA to checkout, or null for current state
 * @returns {Object|null} The type coverage data or null if failed
 */
function runTypeCoverage(commitSha = null) {
  const originalBranch = commitSha ? getCurrentBranch() : null;

  try {
    if (commitSha) {
      console.log(`Checking out commit ${commitSha} for baseline coverage...`);
      execSync(`git checkout ${commitSha}`, {
        cwd: WORKSPACE_PATH,
        stdio: 'pipe',
      });

      // Reinstall dependencies and rebuild if needed
      console.log('Installing dependencies for baseline...');
      execSync('yarn install --frozen-lockfile', {
        cwd: WORKSPACE_PATH,
        stdio: 'pipe',
      });

      console.log('Building TypeScript references for baseline...');
      execSync('yarn update-ts-references --frozen', {
        cwd: WORKSPACE_PATH,
        stdio: 'pipe',
      });
    }

    console.log(`Running type coverage${commitSha ? ' for baseline' : ''}...`);
    const output = execSync('npx type-coverage --detail --json-output', {
      encoding: 'utf8',
      maxBuffer: 1024 * 1024 * 100, // 100MB buffer
      cwd: WORKSPACE_PATH,
    });

    const data = JSON.parse(output);
    if (data?.succeeded) {
      console.log(
        `Coverage${commitSha ? ' (baseline)' : ''}: ${data.percentString}%`,
      );
      console.log(
        `Found ${data.details ? data.details.length : 0} type issues`,
      );
    } else {
      console.error(`Type coverage failed${commitSha ? ' for baseline' : ''}:`);
    }

    return data;
  } catch (error) {
    console.error(
      `Type coverage failed${commitSha ? ' for baseline' : ''}:`,
      error.message,
    );
    return null;
  } finally {
    if (commitSha && originalBranch) {
      try {
        console.log(`Switching back to ${originalBranch}...`);
        execSync(`git checkout ${originalBranch}`, {
          cwd: WORKSPACE_PATH,
          stdio: 'pipe',
        });

        // Reinstall dependencies for current state
        console.log('Reinstalling dependencies for current state...');
        execSync('yarn install --frozen-lockfile', {
          cwd: WORKSPACE_PATH,
          stdio: 'pipe',
        });

        console.log('Rebuilding TypeScript references for current state...');
        execSync('yarn update-ts-references --frozen', {
          cwd: WORKSPACE_PATH,
          stdio: 'pipe',
        });
      } catch (switchError) {
        console.error(
          'Failed to switch back to original branch:',
          switchError.message,
        );
      }
    }
  }
}

/**
 * Get the current branch name
 * @returns {string|null} The current branch name or null if failed
 */
function getCurrentBranch() {
  try {
    return execSync('git rev-parse --abbrev-ref HEAD', {
      encoding: 'utf8',
      cwd: WORKSPACE_PATH,
    }).trim();
  } catch (error) {
    console.error('Failed to get current branch:', error.message);
    return null;
  }
}

/**
 * Generate a type coverage comment for GitHub PRs
 * Compares current coverage with baseline if available
 */
function generateTypeCoverageComment() {
  const baselineCommit = getBaselineCommit();

  // Get baseline coverage if we have a baseline commit
  let baselineData = null;
  if (baselineCommit) {
    baselineData = runTypeCoverage(baselineCommit);
  }

  // Get current coverage
  const currentData = runTypeCoverage();

  if (!currentData) {
    return `## ðŸ“Š Type Coverage Report\n\nâŒ **Error**: Unable to generate type coverage report for current commit.\n\n---\n*This report was generated by the Type Coverage GitHub Action*`;
  }

  return formatTypeCoverageComment(currentData, baselineData);
}

/**
 * Calculate the difference between two coverage percentages
 * @param {number} current - Current coverage percentage
 * @param {number} baseline - Baseline coverage percentage
 * @returns {Object} Object with diff value and formatted string
 */
function calculateCoverageDiff(current, baseline) {
  const diff = current - baseline;
  const sign = diff > 0 ? '+' : '';
  const emoji = diff > 0 ? 'ðŸ“ˆ' : diff < 0 ? 'ðŸ“‰' : 'âž¡ï¸';
  return {
    diff,
    formatted: `${sign}${diff.toFixed(2)}%`,
    emoji,
  };
}

/**
 * Format the type coverage data into a markdown comment
 * @param {Object} currentData - The current type coverage data
 * @param {Object|null} baselineData - The baseline type coverage data (optional)
 * @returns {string} The formatted markdown comment
 */
function formatTypeCoverageComment(currentData, baselineData) {
  // Group details by file to create a summary table
  const fileStats = {};
  if (currentData.details) {
    currentData.details.forEach((detail) => {
      // Strip workspace path to show relative paths in the comment
      let file = detail.filePath;
      if (file.startsWith(WORKSPACE_PATH)) {
        file = file.substring(WORKSPACE_PATH.length);
      }
      // Ensure we don't have leading slash after stripping
      file = file.replace(/^\//, '');

      if (!fileStats[file]) {
        fileStats[file] = {issues: 0, lines: new Set()};
      }
      fileStats[file].issues += 1;
      fileStats[file].lines.add(detail.line);
    });
  }

  // Convert to array and sort by number of issues
  const fileArray = Object.entries(fileStats)
    .map(([file, stats]) => ({
      file,
      issues: stats.issues,
      uniqueLines: stats.lines.size,
    }))
    .sort((a, b) => b.issues - a.issues)
    .slice(0, MAX_FILES); // Show top files with most issues

  let comment = `## ðŸ“Š Type Coverage Report\n\n`;

  // Add baseline comparison if available
  if (baselineData?.succeeded) {
    const coverageDiff = calculateCoverageDiff(
      parseFloat(currentData.percentString),
      parseFloat(baselineData.percentString),
    );

    const untypedDiff =
      currentData.totalCount -
      currentData.correctCount -
      (baselineData.totalCount - baselineData.correctCount);

    comment += `### Coverage Comparison\n`;
    comment += `| Metric | Baseline | Current | Change |\n`;
    comment += `|--------|----------|---------|--------|\n`;
    comment += `| **Coverage Percentage** | ${baselineData.percentString}% | ${currentData.percentString}% | ${coverageDiff.emoji} ${coverageDiff.formatted} |\n`;
    comment += `| **Correctly Typed** | ${baselineData.correctCount.toLocaleString()} | ${currentData.correctCount.toLocaleString()} | ${currentData.correctCount - baselineData.correctCount >= 0 ? '+' : ''}${(currentData.correctCount - baselineData.correctCount).toLocaleString()} |\n`;
    comment += `| **Total Expressions** | ${baselineData.totalCount.toLocaleString()} | ${currentData.totalCount.toLocaleString()} | ${currentData.totalCount - baselineData.totalCount >= 0 ? '+' : ''}${(currentData.totalCount - baselineData.totalCount).toLocaleString()} |\n`;
    comment += `| **Untyped Expressions** | ${(baselineData.totalCount - baselineData.correctCount).toLocaleString()} | ${(currentData.totalCount - currentData.correctCount).toLocaleString()} | ${untypedDiff >= 0 ? '+' : ''}${untypedDiff.toLocaleString()} |\n\n`;
    comment += `| **Status** | ${currentData.succeeded ? 'âœ… Success' : 'âŒ Failed'} |\n\n`;
  } else {
    comment += `### Overall Coverage\n`;
    comment += `| Metric | Value |\n`;
    comment += `|--------|-------|\n`;
    comment += `| **Coverage Percentage** | ${currentData.percentString}% |\n`;
    comment += `| **Correctly Typed** | ${currentData.correctCount.toLocaleString()} |\n`;
    comment += `| **Total Expressions** | ${currentData.totalCount.toLocaleString()} |\n`;
    comment += `| **Untyped Expressions** | ${(currentData.totalCount - currentData.correctCount).toLocaleString()} |\n`;
    comment += `| **Status** | ${currentData.succeeded ? 'âœ… Success' : 'âŒ Failed'} |\n\n`;

    comment += `**Note**: No baseline data available to compare with.\n\n`;
  }

  if (fileArray.length > 0) {
    comment += `### Files with Most Type Issues (Top ${MAX_FILES})\n`;
    comment += `| File | Issues | Affected Lines |\n`;
    comment += `|------|--------|----------------|\n`;

    fileArray.forEach((item) => {
      comment += `| \`${item.file}\` | ${item.issues} | ${item.uniqueLines} |\n`;
    });
    comment += `\n`;
  }

  comment += `\n---\n`;
  comment += `*This report was generated by the Type Coverage GitHub Action*`;

  return comment;
}

module.exports = {generateTypeCoverageComment};
