/* eslint-disable no-console */

const {execSync} = require('child_process');

const WORKSPACE_PATH = process.env.GITHUB_WORKSPACE ?? '';
const MAX_FILES = 15;

/**
 * Generate a type coverage comment for GitHub PRs
 * Runs yarn type-coverage internally and generates a formatted comment
 */
function generateTypeCoverageComment() {
  try {
    console.log('Running type coverage with details...');
    const output = execSync(
      'node node_modules/.bin/type-coverage --detail --json-output',
      {
        encoding: 'utf8',
        maxBuffer: 1024 * 1024 * 100, // 100MB buffer
      },
    );
    const data = JSON.parse(output);

    console.log(`Coverage: ${data.percentString}%`);
    console.log(`Found ${data.details ? data.details.length : 0} type issues`);

    return formatTypeCoverageComment(data);
  } catch (error) {
    console.error('Type coverage failed:', error.message);
    return `## 📊 Type Coverage Report\n\n❌ **Error**: Unable to generate type coverage report.\n\nError: ${error.message}\n\n---\n*This report was generated by the Type Coverage GitHub Action*`;
  }
}

/**
 * Format the type coverage data into a markdown comment
 * @param {Object} data - The type coverage data (includes both basic and detailed info)
 * @param {string} workspacePath - The workspace path to strip from file paths
 * @param {Object} options - Formatting options
 * @returns {string} The formatted markdown comment
 */
function formatTypeCoverageComment(data) {
  // Group details by file to create a summary table
  const fileStats = {};
  if (data.details) {
    data.details.forEach((detail) => {
      // Strip workspace path to show relative paths in the comment
      let file = detail.filePath;
      if (file.startsWith(WORKSPACE_PATH)) {
        file = file.substring(WORKSPACE_PATH.length);
      }
      // Ensure we don't have leading slash after stripping
      file = file.replace(/^\//, '');

      if (!fileStats[file]) {
        fileStats[file] = {issues: 0, lines: new Set()};
      }
      fileStats[file].issues += 1;
      fileStats[file].lines.add(detail.line);
    });
  }

  // Convert to array and sort by number of issues
  const fileArray = Object.entries(fileStats)
    .map(([file, stats]) => ({
      file,
      issues: stats.issues,
      uniqueLines: stats.lines.size,
    }))
    .sort((a, b) => b.issues - a.issues)
    .slice(0, MAX_FILES); // Show top 20 files with most issues

  let comment = `## 📊 Type Coverage Report\n\n`;
  comment += `### Overall Coverage\n`;
  comment += `| Metric | Value |\n`;
  comment += `|--------|-------|\n`;
  comment += `| **Coverage Percentage** | ${data.percentString}% |\n`;
  comment += `| **Correctly Typed** | ${data.correctCount.toLocaleString()} |\n`;
  comment += `| **Total Expressions** | ${data.totalCount.toLocaleString()} |\n`;
  comment += `| **Untyped Expressions** | ${(data.totalCount - data.correctCount).toLocaleString()} |\n`;
  comment += `| **Status** | ${data.succeeded ? '✅ Success' : '❌ Failed'} |\n\n`;

  if (fileArray.length > 0) {
    comment += `### Files with Most Type Issues (Top 20)\n`;
    comment += `| File | Issues | Affected Lines |\n`;
    comment += `|------|--------|----------------|\n`;

    fileArray.forEach((item) => {
      comment += `| \`${item.file}\` | ${item.issues} | ${item.uniqueLines} |\n`;
    });
    comment += `\n`;
  }

  comment += `\n---\n`;
  comment += `*This report was generated by the Type Coverage GitHub Action*`;

  return comment;
}

module.exports = {generateTypeCoverageComment};
